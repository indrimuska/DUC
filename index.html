<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DUC - Distributed UAVs Coordinator</title>
<meta name="author" content="https://plus.google.com/u/0/+IndriMuska" />
<style>
body{padding:0;margin:0;font-size:12px;font-family:'Helvetica Neue',arial,sans-serif;}
html,body,#map{width:100%;height:100%;}
button{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px;cursor:pointer;color:#333;background:#fff;border:1px solid #ccc;}
button:hover{color:#333;background:#ebebeb;border-color:#adadad;}
button:active{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125);}
button[disabled]{opacity:0.2;cursor:not-allowed;}
button.blue{color:#fff;background:#428bca;border-color:#357ebd;}
button.blue:hover{color:#fff;background:#3276b1;border-color:#285e8e;}
button.green{color:#fff;background:#5cb85c;border-color:#4cae4c;}
button.green:hover{color:#fff;background:#47a447;border-color:#398439;}
button.cyan{color:#fff;background:#5bc0de;border-color:#46b8da;}
button.cyan:hover{color:#fff;background:#5bc0de;border-color:#46b8da;}
button.yellow{color:#fff;background:#f0ad4e;border-color:#eea236;}
button.yellow:hover{color:#fff;background:#ed9c28;border-color:#d58512;}
button.red{color:#fff;background:#d9534f;border-color:#d43f3a;}
button.red:hover{color:#fff;background:#d2322d;border-color:#ac2925;}
button>img{vertical-align:-1.5px;margin-right:3px;}
#controls{display:none;}
#tilt{cursor:pointer;margin-right:34px;margin-top:-5px;}
#settings{color:#7f7f7f;background:#fff;box-shadow:0 1px 3px #666;border-radius:2px;padding:10px;margin:10px;}
#settings div{position:relative;line-height:18px;min-width:195px;}
#settings input{color:#666;border:0;border-bottom:1px solid #999;position:absolute;left:140px;outline:none;padding:1px;margin:0;}
#settings input[disabled]{opacity:0.6;cursor:not-allowed}
#settings input[type=number],#settings input[type=text]{width:50px;}
#settings input[type=range]{position:relative;display:block;left:0;width:180px;padding:1px;}
#settings #total{position:absolute;right:5px;display:inline-block;bottom:0;min-width:initial;line-height:25px;}
#settings #total>label{display:inline-block;min-width:inherit;vertical-align:-13px;margin-bottom:-7px;margin-right:3px;}
#settings #total>label>input{position:inherit;left:inherit;display:block;}
#settings #total>img,#settings #total>span{vertical-align:middle;}
hr{background:none;border:0;border-bottom:1px dashed #ccc;margin:10px 0;}
.text{width:100px;text-align:center;margin:0;padding:0;}
</style>
</head>
<body>

<div id="controls">
	<img alt="Tilt" id="tilt" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAG2YAABzjgAA2e0AAIGfAAB/mgAA2GMAADIXAAAdLVvevdMAAAFtSURBVHja1JQ9bsJAEEbfrH9whUhhi4iCA6SDHAFxFVpfhxQ0SJyD0kVEZ26AjEgRQoRkTMymwCExxkoUnCKftMU33nlezc6OaK2pWiaAiLKAW8C9gvUERMAeEAFph2E41FcoDMMhSPvIQxRIV1cgkC6IUoCquKRKAUbFUMME5NKXJElYr9cn73keq9Xq5BuNBrZtX0oVs+x30+mU2Wx28r7vMxqNTr7T6dDv98tb6lxxHBNFEZ7nfSmUyvkoiojjGMdxikcFcYA7rQ+PH8HlckmSJLmNrVaLxWKRi9m2TbPZ/ISJugfCwkk3mw3j8Zg0TXNx3/eZTCb5GzEMBoMB9Xo9f/3n0CAICsAypWlKEATf19R1XXq9XmGjZVkX44ZxsSPFqfhFOYo/0P+Dbufz+cNPkw6HQ6FDsvztR/PXgBugeeVwSYEl8GxkQxVAZ1CjbMiUSAM74AV4BRI5DmksoJYt8xfQtwy8A/bvAwDr7THsYuJubgAAAABJRU5ErkJggg==" />
	<img alt="Play" id="play" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAG2YAABzjgAA2e0AAIGfAAB/mgAA2GMAADIXAAAdLVvevdMAAAB6SURBVHjalNKxDcJgDIRRQ+hokiojMAQzMAsrsEPEAmyRJiukpwsLpE7Do+GXEBJgTrJkF5/OZzkQuKJD/Zw/VmmKZhxRZYGiEft/ALjjgjYLvK+5yQJFA2Idea0iIuVwwyGTYcEJ20zoHrvMWadX+2/AhDOaX6/xGABl3MVhFKqP0QAAAABJRU5ErkJggg==" />
	<img alt="Pause" id="pause" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAG2YAABzjgAA2e0AAIGfAAB/mgAA2GMAADIXAAAdLVvevdMAAAA5SURBVHjaYvj//z8DFH/5DwFf8Ikx/v//nwEK4AwGBgZGXGJMDCSCUQ2DT8MPKP0dnxgAAAD//wMAhfIym9jDvvgAAAAASUVORK5CYII=" />
	<form id="settings">
		<div>Nodes: <input type="number" id="nodes" value="10" /></div>
		<div>Destinations: <input type="number" id="destinations" value="4" /></div>
		<div>Coverage radius [m]: <input type="number" id="coverage" value="13" /></div>
		<div>Velocity [m/s]: <input type="number" id="velocity" value="10" step="0.5" /></div>
		<div>Angular velocity [rad/s]: <input type="number" id="angularVelocity" value="1.5707963267948966" step="0.1" /></div>
		<hr />
		<div>Control period: <input type="text" id="controlLabel" readonly /> <input type="range" id="control" min="20" max="3000" step="10" value="50" /></div>
		<div>Algorithm period: <input type="text" id="algorithmLabel" readonly /> <input type="range" id="algorithm" min="20" max="3000" step="10" value="500" /></div>
		<div>Map refresh period: <input type="text" id="mapRefreshLabel" readonly /> <input type="range" id="mapRefresh" min="20" max="3000" step="10" value="50" /></div>
		<hr />
		<div>
			<button type="submit" class="blue" id="start">Start</button>
			<button type="button" class="cyan" id="stop" disabled>Pause</button>
			<div id="total">
				<label>
					<input type="checkbox" id="follow" checked />
					<img alt="Follow nodes" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR4Xu2Q0QmAMAxEz+AAuokdwck7gm7QFTKC93EoWIKW/vbB4yAh9xEMMNGFFmWE0xVCN5kmuwcR9X6jWQlT+xf1sZjRxoEXhkZ6CxL1noKT7sqn4McjPS4ZXDjPDfJSaA7uAAAAAElFTkSuQmCC" />
				</label>
				<img alt="Time" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAA/UlEQVQ4ja3SPyuGURgG8N/jXd7XRhabgWKWEqWIgbL4EMQmk0HeQSIfwWfgA8hksMugSITJIJM/pRiex+t0nOftKa7pnPu+7qvrPtfhj6hV4KyiB3f4iJsdFQR68YQNLCErI2aYStSbwXkMu6FI6GAFz6i3cXaKAyzHjQZ2AtEm+susFtxOfh5xFme4xyeucYJHnCcE3jGIq+/CGroi0kIhtp4Q6Jan09o183vvQ2ziJSFQE6Uxj4kEsQyTmAsLDXk8VbEnT6tl+xUPGK0wPI5bvMWNDNsYbjM8gi3B/vG3zLCIPhzhoqgPYQY32I8HUqhjGgPF/RLH8vz/F1+T0ycUy1HYAAAAAABJRU5ErkJggg==" />
				<span id="time">0.00s</span>
			</div>
		</div>
	</form>
</div>

<div id="map" />

<script src="http://maps.googleapis.com/maps/api/js?sensor=false"></script>
<script src="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerwithlabel/1.1.8/src/markerwithlabel_packed.js"></script>
<script>
// Math utilites
Math.degToRadConst = Math.PI / 180;
Math.toRadians = function (angle) { return angle * Math.degToRadConst; }
Math.toDegrees = function (angle) { return angle / Math.degToRadConst; }
Math.rand = function (min, max) { return (1 - Math.random()) * (max - min) + min; }

// Geo-coordinates
function Coordinates(lat, lng, alt) {
	this.lat = lat || 0;
	this.lng = lng || 0;
	this.alt = alt || 0;
	
	var earthRadius = 6378137;
	var eccentricity2 = 6.69437999014e-3
	var eccentricity = Math.sqrt(eccentricity2);
	var clockwiseUsage = false; // from North
	// conversions
	this.toGoogleMaps = function () {
		return new google.maps.LatLng(this.lat, this.lng);
	}
	this.toMercatorProjection = function () {
		var rLat = Math.toRadians(this.lat);
		var scaledRadius = earthRadius * Math.cos(rLat);
		return {
			x: scaledRadius * Math.toRadians(this.lng),
			y: scaledRadius * Math.log(Math.tan(Math.PI / 4 + rLat / 2)),
			z: this.alt
		};
	}
	this.fromMercatorProjection = function (point, lat) {
		var scaledRadius = earthRadius * Math.cos(lat ? Math.toRadians(lat) : 0);
		this.lat = Math.toDegrees(2 * Math.atan(Math.exp(point.y / scaledRadius)) - Math.PI / 2);
		this.lng = Math.toDegrees(point.x / scaledRadius);
		this.alt = point.z;
		return this;
	}
	this.toSimplestProjection = function () {
		var rLat = Math.toRadians(this.lat);
		return {
			x: earthRadius * Math.cos(rLat) * Math.toRadians(this.lng),
			y: earthRadius * rLat,
			z: this.alt
		};
	}
	this.fromSimplestProjection = function (point) {
		this.lat = Math.toDegrees(point.y / earthRadius);
		this.lng = Math.toDegrees(point.x / (earthRadius * Math.cos(Math.toRadians(this.lat))));
		this.alt = point.z;
		return this;
	}
	// on a great circle path
	this.greatCircleDistanceTo = function (point) {
		// I don't use haversine formula because it returns bad-conditioned results
		// ** Haversine formula - R. W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol 68, no 2, 1984
		var cosLat1 = Math.cos(Math.toRadians(this.lat));
		var cosLat2 = Math.cos(Math.toRadians(point.lat));
		var cosLngD = Math.cos(Math.toRadians(Math.abs(point.lng - this.lng)));
		
		var sinLat1 = Math.sin(Math.toRadians(this.lat));
		var sinLat2 = Math.sin(Math.toRadians(point.lat));
		var sinLngD = Math.sin(Math.toRadians(Math.abs(point.lng - this.lng)));
		
		var y = Math.sqrt(Math.pow(cosLat2 * sinLngD, 2) + Math.pow(cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosLngD, 2));
		var x = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosLngD;
		return earthRadius * Math.atan2(y, x);
	}
	this.initialBearingTo = function (point) {
		var lat1 = Math.toRadians(this.lat);
		var lat2 = Math.toRadians(point.lat);
		var dLng = Math.toRadians(point.lng - this.lng);
		
		var y = Math.sin(dLng) * Math.cos(lat2);
		var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
		var bearing = Math.atan2(y, x);
		return clockwiseUsage ? bearing : -bearing + Math.PI / 2;
	}
	this.finalBearingTo = function (point) {
		return (point.initialBearingTo(this) + (clockwiseUsage ? 1 : -1) * Math.PI) % (2 * Math.PI);
	}
	this.destination = function (bearing, distance) {
		if (!clockwiseUsage) bearing = -bearing + Math.PI / 2;
		var dR = distance / earthRadius;
		var rLat = Math.toRadians(this.lat);
		var lat = Math.asin(Math.sin(rLat) * Math.cos(dR) + Math.cos(rLat) * Math.sin(dR) * Math.cos(bearing));
		var lng = Math.toRadians(this.lng) + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(rLat), Math.cos(dR) - Math.sin(rLat) * Math.sin(lat))
		return new Coordinates(Math.toDegrees(lat), Math.toDegrees(lng), this.alt);
	}
	this.middlePointTo = function (point) {
		var lat1 = Math.toRadians(this.lat);
		var lng1 = Math.toRadians(this.lng);
		var lat2 = Math.toRadians(point.lat);
		var dLng = Math.toRadians(point.lng - this.lng);
		
		var Bx = Math.cos(lat2) * Math.cos(dLng);
		var By = Math.cos(lat2) * Math.sin(dLng);
		var lat = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt(Math.pow(Math.cos(lat1) + Bx, 2) + Math.pow(By, 2)));
		var lng = lng1 + Math.atan2(By, Math.cos(lat1) + Bx);
		return new Coordinates(Math.toDegrees(lat), Math.toDegrees(lng), (this.alt + point.alt) / 2);
	}
	// on loxodromic curves
	this.loxodromicDistanceTo = function (point) {
		var lat1 = Math.toRadians(this.lat);
		var dLat = Math.toRadians(point.lat - this.lat);
		var dLng = Math.toRadians(point.lng - this.lng);
		
		var dPhi = Math.log(Math.tan(Math.PI / 4 + Math.toRadians(point.lat) / 2) / Math.tan(Math.PI / 4 + lat1 / 2));
		// E-W line gives dPhi=0
		var q = isFinite(dLat / dPhi) ? dLat / dPhi : Math.cos(lat1);
		// if dLng over 180° take shorter rhumb across anti-meridian
		if (Math.abs(dLng) > Math.PI) dLng += (dLon > 0 ? -1 : +1) * 2 * Math.PI;
		return earthRadius * Math.sqrt(Math.pow(dLat, 2) + Math.pow(q, 2) * Math.pow(dLng, 2));
	}
	this.loxodromicBearingTo = function (point) {
		// on a rhumb line (or loxodrome)
		var dLng = Math.toRadians(point.lng - this.lng);
		var dPhi = Math.log(Math.tan(Math.PI / 4 + Math.toRadians(point.lat) / 2) / Math.tan(Math.PI / 4 + Math.toRadians(this.lat) / 2));
		var bearing = Math.atan2(dLng, dPhi);
		return clockwiseUsage ? bearing : -bearing + Math.PI / 2;
	}
	this.loxodromicMiddlePointTo = function (point) {
		var dLat = Math.toRadians(point.lat - this.lat);
		var dLng = Math.toRadians(point.lng - this.lng);
		
		var lat = (this.lat + point.lat) / 2;
		var f1 = Math.tan(Math.PI / 4 + Math.toRadians(this.lat) / 2);
		var f2 = Math.tan(Math.PI / 4 + Math.toRadians(point.lat) / 2);
		var f3 = Math.tan(Math.PI / 4 + Math.toRadians(lat) / 2);
		var lng = (dLng * Math.log(f3) + Math.toRadians(this.lng) * Math.log(f2) - Math.toRadians(point.lng) * Math.log(f1)) / Math.log(f2 / f1);
		// parallel of latitude
		lng = !isFinite(lng) ? (this.lng + point.lng) / 2 : Math.toDegrees(lng);
		// normalize to [-180, +180°]
		lng = (lng + 540) % 360 - 180;
		return new Coordinates(lat, lng, (this.alt + point.alt) / 2);
	}
}

// nodes and points need to be global
var nodes = [], destinations = [], masters = [], map = new Map();

function Node(number, coordinates, orientation) {
	// node status
	var number			= number;			// node number (ID)
	var coordinates		= coordinates;		// intial position
	var orientation		= orientation;		// direction angle
	var radius;								// coverage radius
	var nodes;								// number of total nodes
	
	// other vars
	var precision		= 0.01;				// minimum distance from the target (in meters)
	var lastUpdateTime;						// algorithm's time refresh coefficient
	
	// SOM parameters
	var alphaZero		= 1;				// initial learning rate
	var alphaDecay		= 1;
	var sigmaZero;							// initial neighbour radius (initial value must be equal to the nr. of nodes)
	var sigmaDecay		= 0.99;
	var limit			= 0.5;				// reset limit
	var limitDecay		= 0.9;
	var reset;								// reset counter (initial value must be 1)
	
	// target point and neighbour nodes
	var arrival;							// only masters has arrival set
	var prevNode;							// previuous neighbour (if exists)
	var nextNode;							// next neighbour (if exists)
	var command;							// operation to be complete
	
	// mobility parameters
	var control;							// control timer
	var refuseCounter;						// counter for refusing assinged target (initial value must be 0)
	var refuseLimit		= 3;
	var rotationPole	= 0.8;				// LPF pole of rotation
	var movingPole		= 0.8;				// LPF pole of moving
	
	// SOM functions
	function learningRateUpdate() {
		return command.alpha * alphaDecay;
	}
	function neighbourRadiusUpdate() {
		if (command.sigma <= limit) {
			command.alpha = alphaZero;
			command.sigma = sigmaZero;
			limit *= limitDecay;
			reset++;
		}
		return command.sigma * sigmaDecay;
	}
	function neighbourhoodFunction(distance, sigma) {
		return Math.exp(- Math.pow(distance, 2) / (2 * reset * Math.pow(sigma, 2)));
	}
	function isInNeighbourhood(number, winner, sigma) {
		var integerSigma	= Math.ceil(sigma + 1);
		var firstNeighbour	= Math.max(winner - integerSigma, 0);
		var lastNeighbour	= Math.min(winner + integerSigma, nodes - 1);
		return number >= firstNeighbour && number <= lastNeighbour;
	}
	
	// geometrical functions
	function lineParameters(from, to) {
		var m = (to.y - from.y) / (to.x - from.x);
		var q = from.y - m * from.x;
		return { m: m, q: q };
	}
	function parabolaSolutions(a, b, c) {
		var delta = Math.pow(b, 2) - (4 * a * c);
		if (delta < 0) return NaN;
		var x1 = (-b + Math.sqrt(delta)) / (2 * a);
		var x2 = (-b - Math.sqrt(delta)) / (2 * a);
		return [ x1, x2 ];
	}
	function intersectLineAndCircle(line, center, radius, point) {
		if (!Number.isFinite(line.m)) {
			var a = 1;
			var b = -2 * center.y;
			var c = Math.pow(point.x, 2) + Math.pow(center.x, 2) + Math.pow(center.y, 2) - Math.pow(radius, 2) - (2 * point.x * center.x);
			var solutions = parabolaSolutions(a, b, c);
			return [
				{ x: point.x, y: solutions[0], z: 0 },
				{ x: point.x, y: solutions[1], z: 0 }
			];
		}
		var a = 1 + Math.pow(line.m, 2);
		var b = (-2 * center.x) + (2 * line.m * line.q) - (2 * line.m * center.y);
		var c = Math.pow(center.x, 2) + Math.pow(center.y, 2) + Math.pow(line.q, 2) - Math.pow(radius, 2) - (2 * line.q * center.y);
		var solutions = parabolaSolutions(a, b, c);
		var x1 = solutions[0];
		var x2 = solutions[1];
		return [
			{ x: x1, y: (line.m * x1) + line.q, z: 0 },
			{ x: x2, y: (line.m * x2) + line.q, z: 0 }
		];
	}
	function anglesDifference(alpha, beta) {
		var difference = beta - alpha;
		if (difference > Math.PI) difference -= 2 * Math.PI;
		if (difference < -Math.PI) difference += 2 * Math.PI;
		return difference;
	}
	function isInsideCircle(point, center, radius) {
		return point.greatCircleDistanceTo(center) - radius <= precision;
	}
	
	// geometrical functions (2)
	function isArrived(target) {
		return coordinates.greatCircleDistanceTo(target) <= precision;
	}
	function middlePoint() {
		var prev = prevNode ? prevNode.coordinates : coordinates;
		var next = nextNode ? nextNode.coordinates : coordinates;
		return prev.middlePointTo(next);
	}
	function directionPoints(from, to) {
		var points = new Array();
		// average latitude (required for the Mercator inverse) - don't include destination point, it could be very far
		var lats = [ from.lat, prevNode ? prevNode.coordinates.lat : null, nextNode ? nextNode.coordinates.lat : null ].filter(function (v) { return v; });
		var avgLat = lats.reduce(function (a, b) { return a + b; }) / lats.length;
		// projected coordinates
		from = from.toSimplestProjection();
		to = to.toSimplestProjection();
		// line parameters
		var line = lineParameters(from, to);
		// intersection points with the previous neighbour
		if (prevNode) points = points.concat(intersectLineAndCircle(line, prevNode.coordinates.toSimplestProjection(), radius, from));
		// intersection points with the next neighbour
		if (nextNode) points = points.concat(intersectLineAndCircle(line, nextNode.coordinates.toSimplestProjection(), radius, from));
		// convert from Mercator projection to Geo-coordinates
		for (var i in points) {
			var point = new Coordinates().fromSimplestProjection(points[i], avgLat);
			point.alt = (from.alt + to.alt) / 2;
			points[i] = point;
		}
		return points;
	}
	
	// control functions
	function estimateRotation() {
		return parseFloat(document.getElementById('angularVelocity').value) * parseInt(document.getElementById('control').value) / 1000;
	}
	function estimateMoving() {
		return parseFloat(document.getElementById('velocity').value) * parseInt(document.getElementById('control').value) / 1000;
	}
	function getOrientation(target) {
		// angle in direction of the target
		var ptAngle = coordinates.initialBearingTo(target);
		// difference between the two angles (with sign)
		var difference = anglesDifference(orientation, ptAngle);
		// direction of rotation
		var moltiplier = difference >= 0 ? +1 : -1;
		// absolute rotation angle
		difference = Math.min(estimateRotation(), Math.abs(difference));
		// new orientation angle
		return orientation + difference * moltiplier;
	}
	function getTargetPoint(destination, master, alpha, sigma, phi) {
		// check if the node falls in the neighborhood of master +/- sigma
		if (!isInNeighbourhood(number, master, sigma)) return false;
		// if master is arrived, it doesn't move
		if (arrival && isArrived(arrival)) return false;
		// angle of destination point
		var direction = coordinates.initialBearingTo(destination);
		// compute maximum distance
		var distance = alpha * phi * Math.min(estimateMoving(), coordinates.greatCircleDistanceTo(destination));
		// compute (imminent) target
		var target = coordinates.destination(direction, distance);
		// check if the target is inside the circles of neighbours
		if ((!prevNode || isInsideCircle(target, prevNode.coordinates, radius)) &&
			(!nextNode || isInsideCircle(target, nextNode.coordinates, radius)))
			return target;
		// compute new points of intersection between neighbour circles and the line in the direction of the target
		var points = directionPoints(coordinates, target);
		// choose the one inside both circles (at most 2) and in the right direction (only one)
		for (var i = 0; i < points.length; i++) {
			var point = points[i];
			var isInsidePrev = !prevNode || isInsideCircle(point, prevNode.coordinates, radius);
			var isInsideNext = !nextNode || isInsideCircle(point, nextNode.coordinates, radius);
			var sameDirection = coordinates.initialBearingTo(point) - direction <= precision;
			if (isInsidePrev && isInsideNext && sameDirection && !isArrived(point))
				return point;
		}
		// no target found
		return false;
	}
	
	// simulation functions
	function simulateRotation(rotation) {
		return (1 - rotationPole) * orientation + rotationPole * rotation;
	}
	function simulateMoving(destination) {
		return new Coordinates(
			(1 - movingPole) * coordinates.lat + movingPole * destination.lat,
			(1 - movingPole) * coordinates.lng + movingPole * destination.lng,
			(1 - movingPole) * coordinates.alt + movingPole * destination.alt
		);
	}
	
	// main
	function main() {
		// check if target exists
		if (!command.target) return;
		// update position (or just rotate)
		move(command.target, command.master, command.alpha, command.sigma);
		// only for masters
		if (!arrival) return;
		// destination reached
		if (isArrived(arrival)) {
			console.log("ARRIVED", number);
			// inform other nodes
			sendUpdate('all', number, arrival);
			// stop
			clearInterval(control);
			// to stop the UI after the last node is arrived
			for (var i in masters)
				if (masters[i] == number) {
					masters.splice(i, 1);
					break;
				}
			// exit
			return;
		}
		// time until last update
		var time = new Date().getTime() - lastUpdateTime.getTime();
		// check if algorithm have to update his parameters
		if (time < parseInt(document.getElementById('algorithm').value)) return;
		// update neighbours
		sendUpdate('all', number, arrival, command.alpha, command.sigma);
		// update coefficients
		lastUpdateTime = new Date();
		command.alpha = learningRateUpdate();
		command.sigma = neighbourRadiusUpdate();
	}
	function move(target, master, alpha, sigma) {
		var rotation, destination;
		// calculate possible destinations (middle point is for prevent deadlock on moving)
		var destinations = arrival ? [ arrival ] : [ target, middlePoint() ];
		//destinations = [ target, middlePoint() ];
		// neighbourhood constant
		var phi = neighbourhoodFunction(number - master, sigma);
		// iteration possible destinations
		for (var i in destinations) {
			// calculate destination angle
			rotation = getOrientation(destinations[i]);
			// calculate destination inside neighobur circles
			destination = getTargetPoint(destinations[i], master, alpha, sigma, phi);
			// destination founded
			if (destination) break;
		}
		// rotate
		orientation = simulateRotation(rotation);
		// no destinations avaibles
		if (!destination) return;
		// move to the final destination
		coordinates = simulateMoving(destination);
		// inform other nodes
		sendPosition(number);
	}
	
	// networking functions
	function send(to, message) {
		message = JSON.stringify(message);
		to.receive(message);
	}
	function sendNeighbours(message) {
		// sends the message to the next and previous node
		if (prevNode) send(prevNode, message);
		if (nextNode) send(nextNode, message);
	}
	function sendPosition(master) {
		// inform the nodes that I have changed position
		sendNeighbours({ text: 'new-position', node: number, position: coordinates, orientation: orientation });
	}
	function sendMessageSelective(to, message) {
		// mastes send the message to both neighbours
		if (to == 'all') sendNeighbours(message);
		// other nodes send the message "on cascade"
		else {
			if (prevNode.number == to) send(prevNode, message);
			if (nextNode.number == to) send(nextNode, message);
		}
	}
	function sendUpdate(to, master, target, alpha, sigma) {
		// telling others to move
		sendMessageSelective(to, { text: 'update', node: number, master: master, target: target, alpha: alpha, sigma: sigma });
	}
	function sendArrived(to, winner, target) {
		// telling others the master is arrived
		sendMessageSelective(to, { text: 'arrived', node: number, master: master, target: target });
	}
	
	// neighbour class
	function Neighbour(number, coordinates, orientation, receive) {
		this.number			= number;
		this.coordinates	= coordinates;
		this.orientation	= orientation;
		this.receive		= receive;
	}
	
	// public methods
	this.init = function (iRadius, iNodes, iPrevNode, iNextNode, iArrival) { // damned Apple, "i" stands for "input"
		// stop previous execution
		this.stop();
		// reset old values
		reset = 1;
		prevNode = null;
		nextNode = null;
		refuseCounter = 0;
		lastUpdateTime = new Date();
		command = { target: null, master: null, alpha: null, sigma: null };
		// new values
		radius	= iRadius;
		nodes	= iNodes;
		arrival	= iArrival || null;
		sigmaZero = nodes;
		// neighbours
		if (number > 0) prevNode = new Neighbour(number - 1, iPrevNode.coordinates, iPrevNode.orientation, iPrevNode.receive);
		if (number < nodes-1) nextNode = new Neighbour(number + 1, iNextNode.coordinates, iNextNode.orientation, iNextNode.receive);
		// master's settings
		if (arrival) command = { target: arrival, master: number, alpha: alphaZero, sigma: sigmaZero };
	}
	this.start = function () {
		// start timer
		control = setInterval(main, parseInt(document.getElementById('control').value));
		// start first computation
		main();
	}
	this.stop = function () {
		clearInterval(control);
		control = false;
	}
	this.restart = function () {
		this.stop();
		this.start();
	}
	this.receive = function (message) {
		setTimeout(function () {
			try {
				message = JSON.parse(message);
				switch (message.text) {
					case 'new-position':
						message.position = new Coordinates(message.position.lat, message.position.lng, message.position.alt);
						if (prevNode && prevNode.number == message.node) {
							prevNode.coordinates = message.position;
							prevNode.orientation = message.orientation;
						}
						if (nextNode && nextNode.number == message.node) {
							nextNode.coordinates = message.position;
							nextNode.orientation = message.orientation;
						}
						break;
					case 'update':
						message.target = new Coordinates(message.target.lat, message.target.lng, message.target.alt);
						// masters stop propagation
						if (arrival) return;
						// target already set
						if (command.target && command.target != message.target && ++refuseCounter > refuseLimit)
							refuseCounter = 0;
						// update command
						if (refuseCounter == 0)
							for (var i in command)
								command[i] = message[i];
						// update NEXT neighbour (by propagation)
						var next = 2 * number - message.node;
						sendUpdate(next, message.master, message.target, message.alpha, message.sigma);
						break;
					case 'arrived':
						message.target = new Coordinates(message.target.lat, message.target.lng, message.target.alt);
						// masters stop propagation
						if (arrival) return;
						// remove target
						if (command.target == message.target) command.target = null;
						// inform NEXT neighbour (by propagation)
						var next = 2 * number - message.node;
						sendArrived(next, message.master, message.target);
						break;
				}
			} catch (e) {
				console.error(e);
			}
		}, 1);
	}
	this.position = function () {
		return {
			coordinates: coordinates,
			orientation: orientation
		};
	}
	this.isMaster = function () { return !!arrival; }
	this.getDestination = function () { return arrival; }
}

// google map wrapper
function Map() {
	// map variables
	var that = this, endCallback, lastFitTime = new Date();
	var mapNodes = [], mapDestinations = [], polyline, mapRefresh, running = false;
	var map = new google.maps.Map(document.getElementById('map'), {
		zoom: 3,
		tilt: 0,
		scaleControl: true,
		streetViewControl: false,
		center: new google.maps.LatLng(20, 0),
		//mapTypeId: google.maps.MapTypeId.HYBRID,
		panControlOptions: { position: google.maps.ControlPosition.TOP_RIGHT },
		zoomControlOptions: { position: google.maps.ControlPosition.TOP_RIGHT },
		mapTypeControlOptions: {
			style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
			position: google.maps.ControlPosition.RIGHT_BOTTOM
		}
	});
	map.controls[google.maps.ControlPosition.RIGHT_TOP].push(document.getElementById('tilt'));
	map.controls[google.maps.ControlPosition.TOP_LEFT].push(document.getElementById('settings'));
	
	this.init = function (end) {
		endCallback = end;
		// reset old setting
		for (var i in mapDestinations)
			for (var j in mapDestinations[i])
				mapDestinations[i][j].setMap(null);
		for (var i in mapNodes)
			for (var j in mapNodes[i])
				mapNodes[i][j].setMap(null);
		mapDestinations = [];
		mapNodes = [];
		// initialiaze new settings
		if (destinations.length + nodes.length <= 0) return;
		map.setMapTypeId(google.maps.MapTypeId.HYBRID);
		var bounds = new google.maps.LatLngBounds();
		for (var i in destinations) bounds.extend(destinations[i].toGoogleMaps());
		for (var i in nodes) bounds.extend(nodes[i].position().coordinates.toGoogleMaps());
		map.setCenter(bounds.getCenter());
		map.fitBounds(bounds);
		lastFitTime = new Date();
		this.start();
	}
	this.start = function () {
		running = true;
		for (var i in nodes) nodes[i].start();
		mapRefresh = setInterval(function () {
			if (masters.length == 0) {
				that.stop();
				if (endCallback) endCallback();
			} else draw();
		}, parseInt(document.getElementById('mapRefresh').value));
		draw();
	}
	this.stop = function () {
		running = false;
		clearInterval(mapRefresh);
		for (var i in nodes) nodes[i].stop();
	}
	
	function getScale() {
		return Math.pow(2, map.getZoom()) / 156543.03392;
	}
	function svgCirlce(x, y, r) {
		return	'M' + [ x, y ].join(' ') +
				' m ' + (-r) + ',0' +
				' a ' + [ r, r ].join(',') + ' 0 1,1 ' + (r * 2) + ',0' +
				' a ' + [ r, r ].join(',') + ' 0 1,1 ' + (-r * 2) + ',0';
	}
	function svgArcedTriangle(r, h, overture) {
		var cosOverture = Math.cos(overture / 2);
		var sinOverture = Math.cos(overture / 2);
		var point1 = [ r * cosOverture, r * sinOverture ];
		var point2 = [ r * cosOverture, - r * sinOverture ];
		var point3 = [ r + h, 0 ];
		return	'M' + point1.join(',') +
				' A' + [ r, r ].join(',') + ' 0 0,0 ' + point2.join(',') +
				' L' + point3.join(',') +
				' L' + point1.join(',');
	}
	function draw() {
		// not intialized yet
		if (destinations.length + nodes.length <= 0) return;
		var scale = getScale();
		var nodesGM = nodes.map(function (value) { return value.position().coordinates.toGoogleMaps(); });
		// destinations
		for (var i = 0; i < destinations.length; i++) {
			var destination = destinations[i].toGoogleMaps();
			if (!mapDestinations[i])
				mapDestinations[i] = {
					text: new MarkerWithLabel({
						map: map,
						position: destination,
						clickable: false,
						icon: { path: '', zIndex: 1 },
						labelContent: i.toString(),
						labelClass: 'text',
						labelStyle: { 'font-size': 3 * scale + 'px' },
						labelAnchor: new google.maps.Point(50, -1.3 * scale)
					}),
					circle: new google.maps.Circle({
						map: map,
						center: destination,
						radius: 1,
						fillColor: 'red',
						fillOpacity: 0.9,
						strokeColor: '#900',
						strokeWeight: 1,
						strokeOpacity: 1,
						clickable: false,
						zIndex: 1
					})
				};
			else {
				mapDestinations[i].text.labelStyle = { 'font-size': 3 * scale + 'px' };
				mapDestinations[i].text.labelAnchor = new google.maps.Point(50, -1.3 * scale);
			}
		}
		// nodes
		for (var i = 0; i < nodes.length; i++) {
			var center = nodesGM[i];
			var orientation = -Math.toDegrees(nodes[i].position().orientation);
			if (!mapNodes[i])
				mapNodes[i] = {
					text: new MarkerWithLabel({
						map: map,
						position: center,
						clickable: false,
						icon: { path: '', zIndex: 3 },
						labelContent: i.toString(),
						labelClass: 'text',
						labelStyle: { 'font-size': 2 * scale + 'px' },
						labelAnchor: new google.maps.Point(50, -scale)
					}),
					point: new google.maps.Circle({
						map: map,
						center: center,
						radius: 0.5,
						fillColor: '#35b3e5',
						fillOpacity: 1,
						strokeColor: '#004F74',
						strokeWeight: 1,
						strokeOpacity: 1,
						clickable: false,
						zIndex: 3
					}),
					coverage: new google.maps.Circle({
						map: map,
						center: center,
						radius: parseInt(document.getElementById('coverage').value),
						fillColor: 'green',
						fillOpacity: 0.2,
						strokeColor: 'green',
						strokeWeight: 1,
						strokeOpacity: 0.5,
						clickable: false,
						zIndex: 0
					}),
					orientation: new google.maps.Marker({
						map: map,
						position: center,
						clickable: false,
						icon: {
							path: svgArcedTriangle(scale, scale, Math.PI/2),
							rotation: orientation,
							fillColor: '#35b3e5',
							fillOpacity: 1,
							strokeColor: '#004F74',
							strokeWeight: 1,
							strokeOpacity: 1,
							zIndex: 3
						}
					})
				};
			else {
				mapNodes[i].text.setPosition(center);
				mapNodes[i].text.labelStyle = { 'font-size': 3 * scale + 'px' };
				mapNodes[i].text.labelAnchor = new google.maps.Point(50, -scale);
				mapNodes[i].point.setCenter(center);
				mapNodes[i].coverage.setCenter(center);
				var icon = mapNodes[i].orientation.icon;
				icon.path = svgArcedTriangle(scale, scale, Math.PI/2);
				icon.rotation = orientation;
				mapNodes[i].orientation.setIcon(icon);
				mapNodes[i].orientation.setPosition(center);
			}
		}
		// lines
		if (!polyline)
			polyline = new google.maps.Polyline({
				map: map,
				path: nodesGM,
				geodesic: true,
				strokeColor: '#000',
				strokeOpacity: 1,
				strokeWeight: 1,
				clickable: false,
				zIndex: 2
			});
		else polyline.setPath(nodesGM);
		// fit bounds
		if (document.getElementById('follow').checked && new Date().getTime() - lastFitTime.getTime() > 100) {
			lastFitTime = new Date();
			var bounds = new google.maps.LatLngBounds();
			for (var i in destinations) bounds.extend(destinations[i].toGoogleMaps());
			for (var i in nodes) bounds.extend(nodes[i].position().coordinates.toGoogleMaps());
			map.fitBounds(bounds);
		}
	}
	
	// listeners
	google.maps.event.addListener(map, 'zoom_changed', draw);
	//google.maps.event.addListener(map, 'bounds_changed', draw);
	google.maps.event.addListener(map, 'idle', function () {
		document.getElementById('start').focus();
	});
	document.getElementById('tilt').addEventListener('click', function () {
		map.setTilt((map.getTilt() + 45) % 90);
	});
	document.getElementById('mapRefresh').addEventListener('change', function () {
		clearInterval(mapRefresh);
		if (!running) return;
		that.start();
	});
}

// nodes and destinations initializer
function newDestinations(center) {
	// create nodes
	var lastPosition;
	if (nodes.length != parseInt(document.getElementById('nodes').value)) {
		nodes = [];
		lastPosition = center.destination(Math.PI / 2, 50);
		for (var i = 0; i < parseInt(document.getElementById('nodes').value); i++) {
			nodes[i] = new Node(i, lastPosition, (Math.PI + Math.PI / 4 * i) % (2 * Math.PI));
			lastPosition = lastPosition.destination(0, 5);
		}
	}
	// select destinations
	destinations = [];
	lastPosition = center;
	var lastDirection = 0;
	var ceilDistance = 0;
	var destinationsPoints = parseInt(document.getElementById('destinations').value);
	var coverageRadius = parseInt(document.getElementById('coverage').value);
	var minDistance = 0.7 * coverageRadius;
	var maxDistance = coverageRadius * (nodes.length - destinationsPoints + 1);
	for (var i = 0; i < destinationsPoints; i++) {
		lastDirection = lastDirection + Math.rand(-Math.PI / 3, Math.PI / 3);
		lastPosition = lastPosition.destination(lastDirection, Math.rand(i == destinationsPoints-1 ? maxDistance-minDistance : minDistance, maxDistance));
		destinations[i] = lastPosition;
		if (i == 0) continue;
		var distance = destinations[i].greatCircleDistanceTo(destinations[i-1]);
		var coveredDistance = Math.ceil((distance ? distance : 1) / coverageRadius) * coverageRadius;
		ceilDistance += coveredDistance;
		maxDistance -= coveredDistance - coverageRadius;
	}
	// select masters
	var node = 0;
	masters = [ 0 ];
	lastPosition = destinations[0];
	for (var i = 1; i < destinations.length - 1; i++) {
		var distance = lastPosition.greatCircleDistanceTo(destinations[i]);
		node += Math.ceil((distance ? distance : 1) / coverageRadius);
		lastPosition = destinations[i];
		masters.push(node);
	}
	masters.push(nodes.length - 1);
	// assing destinations
	var d = 0;
	for (var i = 0; i < nodes.length; i++) {
		var prev = i > 0 ? nodes[i-1].position() : null;
		var next = i < nodes.length-1 ? nodes[i+1].position() : null;
		if (prev) prev.receive = nodes[i-1].receive;
		if (next) next.receive = nodes[i+1].receive;
		nodes[i].init(coverageRadius, nodes.length, prev, next, masters.indexOf(i) >= 0 ? destinations[d] : null);
		if (masters.indexOf(i) >= 0) d++;
	}
	
}

var Airport = new Coordinates(43.696, 10.3981395, 0);

var time, startTime, timer;
function setTimer() {
	clearInterval(timer);
	timer = setInterval(function () {
		document.getElementById('time').innerHTML = ((time + (new Date() - startTime)) / 1000).toFixed(2) + "s";
	}, 10);
}
// initialize UI-listeners
var ranges = [ 'control', 'algorithm', 'mapRefresh' ];
var eventChange = document.createEvent('HTMLEvents');
eventChange.initEvent('change', true, true);
for (var i in ranges) {
	var range = ranges[i];
	document.getElementById(range).addEventListener('change', function () {
		var value = parseInt(this.value), prefix;
		for (prefix = 0; value > 1000; prefix++) value /= 1000;
		document.getElementById(this.id + 'Label').value = value.toString() + (prefix == 0 ? 'm' : '') + 's';
	});
	document.getElementById(range).dispatchEvent(eventChange);
}
var btnStart = document.getElementById('start');
var btnStop = document.getElementById('stop');
var btnPlay = document.getElementById('play');
var btnPause = document.getElementById('pause');
document.getElementById('settings').addEventListener('submit', function (e) {
	e.preventDefault();
	// ui setup
	btnStart.innerHTML = 'Reset';
	while (btnStop.hasChildNodes()) btnStop.removeChild(btnStop.firstChild);
	btnStop.disabled = false;
	btnStop.appendChild(btnPause.cloneNode());
	btnStop.appendChild(document.createTextNode('Pause'));
	var uiSet = [ 'nodes', 'destinations', 'coverage' ];
	for (var i in uiSet) document.getElementById(uiSet[i]).disabled = true;
	// init
	time = 0;
	map.stop();
	newDestinations(Airport);
	startTime = new Date();
	map.init(function () {
		console.log("Finish!");
		clearInterval(timer);
		btnStop.disabled = true;
		btnStart.innerHTML = 'Start';
		for (var i in uiSet) document.getElementById(uiSet[i]).disabled = false;
	});
	setTimer();
});
btnStop.insertBefore(btnPause.cloneNode(), btnStop.firstChild);
btnStop.addEventListener('click', function () {
	var text = this.childNodes[1].nodeValue;
	while (this.hasChildNodes()) this.removeChild(this.firstChild);
	if (text == 'Pause') {
		map.stop();
		clearInterval(timer);
		time = new Date() - startTime;
		this.appendChild(btnPlay.cloneNode());
		this.appendChild(document.createTextNode('Play'));
	} else {
		map.start();
		setTimer();
		startTime = new Date();
		this.appendChild(btnPause.cloneNode());
		this.appendChild(document.createTextNode('Pause'));
	}
});
</script>
</body></html>